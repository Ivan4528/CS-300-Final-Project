# CS-300-Final-Project
CS 300 Advising Assistance Program

### What was the problem you were solving in the projects for this course?
The main problem I was solving was creating a software tool that allows academic advisors at ABC University to quickly access course information and prerequisites. The goal was to design and implement a program that could read course data from a file, store it efficiently in a data structure, and provide a menu-driven interface to display course lists or details for individual courses.

### How did you approach the problem?
I approached the problem by first analyzing the requirements and then deciding which data structures would be best for storing and retrieving course data. Data structures are critical because they directly impact the efficiency of operations such as searching, inserting, sorting, and displaying information. I practiced working with three different structuresâ€”vectors, hash tables, and binary search trees before making a final recommendation and implementation. This helped me better understand trade-offs in runtime and memory efficiency.

### How did you overcome any roadblocks you encountered?
Some challenges I encountered included debugging logic errors when parsing input files, dealing with invalid or missing prerequisites, and understanding how to properly traverse and sort data within a tree structure. I overcame these by breaking the problems into smaller parts, reviewing my pseudocode, testing incrementally, and consulting documentation or resources to better understand C++ syntax.

### How has your work on this project expanded your approach to designing software and developing programs?
This project has expanded my approach by reinforcing the importance of design before coding. Writing pseudocode and performing runtime analysis made me think more critically about how software should be structured to handle real world problems efficiently. It also showed me how to connect the needs of users in this case, academic advisors with technical design choices.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Through this project, I have improved in writing modular, well documented code. I learned to keep functions focused on a single responsibility, to use meaningful variable names, and to add inline comments where necessary. This makes the program easier to maintain, debug, and adapt to future requirements. I also better appreciate the role of clarity and structure, both in code and supporting documentation, in creating software that others can understand and use.
